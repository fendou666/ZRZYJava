A1 主要是测试多个线程的wait， 以及一个线程一个地方wait，整个线程都不执行了
	代码采用将线程控制放在basicMangage中，
	通过测试得知，任何地方都可以唤醒线程，但是必须放在这个synchronized(这个对象)下，因为你没有得到锁，
	你怎么可以执行notify， 
	总结，将变化的部分放在锁内， 锁块可以在任何地方， 但是一个时间点只有一个线程执行这些块， 一个块执行完毕，会释放锁
	
A2 将线程控制放在线程类中，Th1,Th2中， BasicManage只做自己的事情，
	关于唤醒，必须采用，notifyAll, notify只是唤醒一个线程，有可能唤醒的是同一个线程类创建的对象，但这并不是我们想要的
	关于自己wait,互相唤醒，先notifyAll，再wait自己

A3 测试多个线程间是怎样竞争执行的，即多个线程总共执行的次数为原共享方法要执行的次数, 多线程会牵涉读取变量出问题，
	读取的可能是别人更改前的变量[指的是共享的成员变量], 此时需要将更改的部分锁如块中
	
A4 经测试并不会独占   (证明一个对象锁的多个块中， 如果一个线程notifyAll()，此时所有线程已经是醒的状态的时候，这个线程独占进程测试)
	 